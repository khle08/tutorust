# 概述
所有权的属性是 `rust` 编程语言最独特的地方，无需垃圾搜集器 GC 就可以保证内存安全，所有程序在运行的时候都需要管理变量与内存的交互方式，许多编程语言如 `Go`, `Java`, `Python` 都有 GC 实时搜寻不再使用的内存并释放，有的则必须手动的释放内存例如 `C`, `C++` 等。`rust` 使用的是所有权系统来管理，编译器会检查其中的规则，自动在变量跳脱作用域的时候就释放内存，这么一来就可以把内存的管理工作提前到编译的时候完成。

# 1. Stack (栈) vs Heap (堆)
在系统级别编程语言里，值是存放在哪里操作需要匹配这个背后的行为才能达到更好的效果

## 1.1 stack
按值的接受顺序来存储，按相反的顺序将其移除（后进先出，LIFO）
+ 压入栈：添加数据
+ 弹出栈：移除数据

所有存储在 stack 的数据必须拥有 **已知** 的固定大小，这种操作和指针无关，不涉及到内存分配问题，编译时大小未知的数据，或者会随着程序运行而改变的数据必须放在 heap 上

## 1.2 heap
当数据放在这的时候，会请求一定数量的空间，并将这个空间标注为在用，同时返回一个指针，也就是常见的 `&` 符号所回传的东西，也就是俗称的 **内存分配**。 

把数据存放到 stack 要比 heap 来的快速，因为少了寻找数据控件的过程，对于现代处理器来讲，如果指令在内存中跳转查找的次数越少，则运行速度越快，并且在 stack 上数据存放的距离近，处理器的速度也能够快一些，反之在 heap 上的话，数据存放的远，是导致速度慢的第二个原因。

当代码调用函数时，参数被传入到函数里，也包含参数本身指向 heap 的指针，函数本地的变量被压到 stack 上，当函数结束后，这些值会被弹出。`rust` 的所有权功能可以用来跟踪代码使用 heap 的空间状态，并做到以下两点：
1. 最小化 heap 上的重复数据量
2. 清理 heap 上未使用的数据，避免空间不足

因此管理 heap 上的数据是所有权的主要工作。

# 2. 所有权规则
1. 每个值都有一个变量，这个变量是该值的所有者
2. 每个值同时只能有一个所有者
3. 当所有者超出作用域时，该值被删除

```rust
{
    let s = "hello";
}

println!("s: {}", s);  // Wrong
```

一旦变量出了自己的作用域，`drop` 函数就会自动被调用，然后把内存归还。

# 3. String 类型
这类数据在理解堆栈的概念时，有代表性的意义，也更加复杂，他有两种状态形式
1. 字符串字面值 - 程序里手写的字符串值，是不可变的
2. 字符串结构体 - String 类型的数据，在 heap 上分配，能够存储在编译时未知数量的文本

因此其实字符串有两种创建方式：

```rust
let s1: &str = "hello world";        // Type 1
let mut s2 = String::from("hello");  // Type 2

// s2 can be longer.
s2.push_str(" , how are you?");

println!("s2: {}", s2);
```

其中 `::` 表示 `from` 是 `String` 类型下的函数，`String` 类型的值可以被修改，而字符串字面值不能修改的主要原因就在于内存处理方式的不同，字面值的长度因为已经确定了，所有在编译的时候就会直接被硬编码到程序里，处理速度很快，反之 `String` 类型则需要内存请求一个空间，随时在程序中等待添加长度。

# 4. 变量和数据的交互
多个变量可以和**同一个数据**完成交互，例如这种常量的赋值操作，已知内存占用长度固定，直接放到 stack 中，因此参数会在离开作用域之后才失效。

```rust
let x = 5;
let y = x;
```

而如果是使用字符串结构体，那这套操作就是在 heap 下完成，一旦参数被关联，前者就会就地失效

```rust
let s1 = String::from("hello");
let s2 = s1;  // move

println!("s1: {:?}", s1);  // Wrong
```

一个 `String` 由四个部分组成
1. 指向存放字符串内容的内存的指针
2. 一个长度 - `len()`
3. 一个容量 - `cap()`
4. 数据内容本身

其中前三者都是固定的，因此放在 stack 中，而最后一个是放在 heap 里，当 `s1` 给到 `s2` 的时候，并没有对第四点复制，而是直接将 stack 里的东西转移给了 `s2`，这么做可以避免二次释放内存的 bug 出现，在 `rust` 语言中，这种操作又叫做移动。如果真的要连 heap 里的数据一起拷贝过去的话，可以使用 `.clone()` 方法

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
```

但要注意的是这种方法比较消耗资源，需要谨慎使用。

## 4.1 Stack 上的数据复制
Copy trait 可以用于如整数这样完全存放在 stack 上的类型，如果一个类型有这个 trait，那么旧的变量在赋值后仍然可用，反之则是这个类型拥有的是 Drop trait，赋值后原变量就会失效。

+ copy: 任何简单的标量组合类型，如 `u32`, `bool`, `char`, `f64`, (`i32`, `i32`), [`f64`, `f64`] ... etc
+ drop: 任何不是 copy 的类型都是 drop 类型，如 (`i32`, `String`)

## 4.2 返回值与作用域
函数在返回值的过程中同样也会发生所有权的转移

```rust
fn take_str(s: String) -> String { s }

let s1 = String::from("hello");
let s2 = take_str(s1);
```

当 `s1` 被传入函数，并切函数返回了值的时候，`s1` 就失效了，只剩下 `s2` 是有效的变量。另外，当一个包含 heap 数据的变量离开了作用域之后，他的数据就会被 `drop` 函数清理掉，除非所有权转移。

## 4.3 无所有权的使用变量 - 引用
使用 `&` 的符号来允许使用变量里存着的某些值，但不获取其所有权

```rust
fn calc_len(s: &String) -> usize {
    s.len()
}

let s1 = String::from("hello");
let s_len = calc_len(&s1);

println!("s1 len: {}", s_len);
```

而且厉害的地方是，引用同样可以修改参数，但前提是这个参数需要是 mutable 的状态，而引用符号也需要添加 `mut`。

```rust
fn calc_len(s: &mut String) -> usize {
    s.push_str(", world");
    s.len()
}

let mut s1 = String::from("hello");
let s_len = calc_len(&mut s1);

println!("s1 len: {}", s_len);
```

但是要注意的是，引用只能够给到一个变量，一个以上就会出错

```rust
let mut s = String::from("hello");
let s1 = &mut s;
let s2 = &mut s;  // Wrong
```

解决这种错误的方式就是让两个引用出现在不同作用域里。

```rust
let mut s = String::from("hello");
{
    let s1 = &mut s;
}
let s2 = &mut s;  // Correct
```

不过，刚刚上面的例子说一个以上的引用就会报错，这是出现在可变变量的情况，如果是对不可变的变量，那就可以多次引用都没有问题。

## 4.4 悬空引用 Dangling Referencing
表示一个指针饮用了内存中的某个地址，而这块内存可能已经释放并分配给其他人使用了，但这种情况是不会在 `rust` 语言中发生的。

```rust
fn dangling() -> &String {
    let s = String::from("hello");
    &s
}

let d = dangling();  // Wrong
```

# 5. 切片 (slice)
这是另一种不支持 **所有权** 的数据类型，可以用来获取部分的数值

```rust
let s = String::from("hello world");
let hello = &s[0..5];     // &s[..5] (alternative)
let world = &s[6..11];    // &s[6..] (alternative)
let all = &s[0..s.len()]  //  &s[..] (alternative)
```

其实字符串切片等于字符串字面值，在设计函数的时候建议使用字符串字面值 `&str` 作为参数类型传入和传出，这样可以使的 API 设计出来更加通用，并且不会有性能的损失，切片可以在不同类型上使用，例如数组



