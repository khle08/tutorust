# 概述

在 `Rust` 语言中每个引用都有自己的生命周期，是用来让引用保持有效的作用域，大多数情况下生命周期是 "隐式" 且可以被推断的，不过，当引用的生命周期可能以不同方式互相关联的时候，就需要手动标注生命周期。生命周期最主要的存在目的就是为了避免：悬垂引用（dangling reference）。

```rust
let r;
{
  let x = 5;
  r = &x;
}
println!("r: {}", r);
```

上面的代码是会报错的，原因就在于在赋予 `r` 值的时候，`x` 已经离开了他的作用域，因此这个代码无效：`borrowed value does not live long enough`。



# 借用检查器

`Rust` 编译器的借用检查器专门用来检查并判断所有的借用是否合法，是否符合生命周期的规则。要让上面的代码变成合法的话，就要确保 `x` 的生命周期比 `r` 还要长，因此修复问题的方式如下：

```rust
let x = 5;
let r = &x;
println!("r: {}", r);
```



# 函数中的范型生命周期

```rust
fn longest(x: &str, y: &str) -> &str {
  if x.len() > y.len() {
    x
  } else {
    y
  }
}

let s1 = String::from("string1");
let s2 = "xyz";

let res = longest(s1.as_str(), s2);
println!("The longest string is {}", res);
```

上述代码示例看起来没什么问题，但实际上他缺少了生命周期的参数 `missing lifetime specifier`。



## 生命周期的标注语法 `'a`

生命周期的标注描述了多个引用的生命周期关系，但不会改变引用的生命周期长度，当指定了范型生命周期参数，函数可以接受带有任何生命周期的引用。生命周期参数有以下几个特性：

+ 以 `'` 开头
+ 通常以小写/短的字段命名
+ 多数人使用 `'a` 来标注生命周期
+ 在引用符号 `&` 后面
+ 使用空格将标注和饮用类型分开：i.e. `&'a i32`
+ 范型生命周期参数声明在 `< ... >` 中

修改上面错误的方式很简单，就是引入一个命名的生命周期参数（a named lifetime parameter）：

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
  // ...
}
```

由于 `x` 和`y` 两个参数的生命周期是不知道的，也不知道输出参数的生命周期，因此无法比较作用域来确认代码是否合规，借用检查器也就无法做到，这时候只能通过 `'a` 来手动确认他们有着同样的生命周期。